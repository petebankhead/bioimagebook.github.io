
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Filters &#8212; Introduction to Bioimage Analysis</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" href="../../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mycss.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="ImageJ: Filters" href="imagej.html" />
    <link rel="prev" title="ImageJ: Thresholding" href="../3-thresholding/imagej.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
<script defer data-domain="bioimagebook.github.io" src="https://plausible.io/js/plausible.js"></script>
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../../_static/book-logo-smaller.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Bioimage Analysis</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../../README.html">
                    Introduction to Bioimage Analysis
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Front matter
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../0-preamble/acknowledgements/acknowledgements.html">
   Acknowledgements
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../0-preamble/license.html">
   License
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../0-preamble/disclaimer.html">
   Disclaimer
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Before we begin
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../0-preamble/preface/preface.html">
   Preface
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../0-preamble/reading/reading.html">
   How to read this book
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introducing images
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../1-concepts/1-images_and_pixels/images_and_pixels.html">
   Images &amp; pixels
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/1-images_and_pixels/imagej.html">
     ImageJ: Images &amp; pixels
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/1-images_and_pixels/python.html">
     Python: Images &amp; pixels
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../1-concepts/2-measurements/measurements.html">
   Measurements &amp; histograms
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/2-measurements/imagej.html">
     ImageJ: Measurements &amp; histograms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/2-measurements/python.html">
     Python: Measurements &amp; histograms
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../1-concepts/3-bit_depths/bit_depths.html">
   Types &amp; bit-depths
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/3-bit_depths/imagej.html">
     ImageJ: Types &amp; bit-depths
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/3-bit_depths/python.html">
     Python: Types &amp; bit-depths
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../1-concepts/4-colors/colors.html">
   Channels &amp; colors
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/4-colors/imagej.html">
     ImageJ: Channels &amp; colors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/4-colors/python.html">
     Python: Channels &amp; colors
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../1-concepts/5-pixel_size/pixel_size.html">
   Pixel size &amp; dimensions
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/5-pixel_size/imagej.html">
     ImageJ:  Pixel size &amp; dimensions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/5-pixel_size/python.html">
     Python:  Pixel size &amp; dimensions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../1-concepts/6-files/files.html">
   Files &amp; file formats
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/6-files/imagej.html">
     ImageJ: Files &amp; file formats
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../1-concepts/6-files/python.html">
     Python: Files &amp; file formats
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Processing &amp; analysis
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../1-processing_and_analysis/processing_and_analysis.html">
   Image processing &amp; analysis
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../2-point_operations/point_operations.html">
   Point operations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../2-point_operations/imagej.html">
     ImageJ: Point operations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../3-thresholding/thresholding.html">
   Thresholding
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../3-thresholding/imagej.html">
     ImageJ: Thresholding
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="current reference internal" href="#">
   Filters
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="imagej.html">
     ImageJ: Filters
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../5-morph/morph.html">
   Morphological operations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../5-morph/imagej.html">
     ImageJ: Morphological operations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../6-transforms/transforms.html">
   Image transforms
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../6-transforms/imagej.html">
     ImageJ: Image transforms
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../7-multidimensional_processing/multidimensional_processing.html">
   Multidimensional processing
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../7-multidimensional_processing/imagej.html">
     ImageJ: Multidimensional processing
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Fluorescence microscopy
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../3-fluorescence/1-formation_overview/formation_overview.html">
   From photons to pixels
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../3-fluorescence/2-formation_spatial/formation_spatial.html">
   Blur &amp; the PSF
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../3-fluorescence/3-formation_noise/formation_noise.html">
   Noise
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../3-fluorescence/4-microscope_types/microscope_types.html">
   Microscopes &amp; detectors
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendices
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../appendices/next_steps/next_steps.html">
   Beyond this book
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../appendices/python/python.html">
   Python Primer
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../appendices/macros/macro_intro.html">
   ImageJ: Writing macros
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendices/macros/macro_dog.html">
     Difference of Gaussians
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendices/macros/macro_simulating.html">
     Simulating image formation
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/bioimagebook/bioimagebook.github.io/main?urlpath=tree/chapters/2-processing/4-filters/filters.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        
<button onclick="initThebeSBT()"
  class="headerbtn headerbtn-launch-thebe"
  data-toggle="tooltip"
data-placement="left"
title="Launch Thebe"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="headerbtn__text-container">Live Code</span>
</button>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../../_sources/chapters/2-processing/4-filters/filters.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download notebook file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-code"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        <a href="../../../_sources/chapters/2-processing/4-filters/filters.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linear-filters">
   Linear filters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mean-filters">
     Mean filters
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gradient-filters">
     Gradient filters
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filtering-at-image-boundaries">
     Filtering at image boundaries
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nonlinear-filters">
   Nonlinear filters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rank-filters">
     Rank filters
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gaussian-filters">
   Gaussian filters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filters-from-gaussian-functions">
     Filters from Gaussian functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filters-of-varying-sizes">
     Filters of varying sizes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#difference-of-gaussians-filtering">
     Difference of Gaussians filtering
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#laplacian-of-gaussian-filtering">
     Laplacian of Gaussian filtering
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unsharp-masking">
     Unsharp masking
    </a>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Filters</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linear-filters">
   Linear filters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#mean-filters">
     Mean filters
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#gradient-filters">
     Gradient filters
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filtering-at-image-boundaries">
     Filtering at image boundaries
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#nonlinear-filters">
   Nonlinear filters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#rank-filters">
     Rank filters
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gaussian-filters">
   Gaussian filters
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filters-from-gaussian-functions">
     Filters from Gaussian functions
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#filters-of-varying-sizes">
     Filters of varying sizes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#difference-of-gaussians-filtering">
     Difference of Gaussians filtering
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#laplacian-of-gaussian-filtering">
     Laplacian of Gaussian filtering
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unsharp-masking">
     Unsharp masking
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="filters">
<span id="chap-filters"></span><h1>Filters<a class="headerlink" href="#filters" title="Permalink to this headline">#</a></h1>
<div class="tip admonition">
<p class="admonition-title">Chapter outline</p>
<ul class="simple">
<li><p><strong>Filtering</strong> can make segmentation much easier by <strong>enhancing features</strong> and <strong>reducing noise</strong></p></li>
<li><p><strong>Linear filters</strong> replace each pixel by a weighted sum of surrounding pixels</p></li>
<li><p><strong>Nonlinear filters</strong> replace each pixel with the result of another computation using surrounding pixels</p></li>
<li><p><strong>Gaussian filters</strong> are linear filters with particularly useful properties, making them a good choice for many applications</p></li>
</ul>
</div>
<div class="cell tag_hide-cell tag_thebe-init docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>%load_ext autoreload
%autoreload 2

# Default imports
import sys
sys.path.append(&#39;../../../&#39;)
from helpers import *
from matplotlib import pyplot as plt
from myst_nb import glue
import numpy as np
from scipy import ndimage
</pre></div>
</div>
</div>
</div>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h2>
<p>Filters are phenomenally useful.
Almost all interesting image analysis involves filtering in some way at some stage.
In fact, the analysis of a difficult image can sometimes become (almost) trivial once a suitable filter has been applied to it.
It’s therefore no surprise that much of the image processing literature is devoted to the topic of designing and testing filters.</p>
<p>The basic idea of filtering here is that each pixel in an image is assigned a new value depending upon the values of other pixels within some defined region (the pixel’s <strong>neighborhood</strong>).
Different filters work by applying different calculations to the neighborhood to get their output.
Although the plethora of available filters can be intimidating at first, knowing only a few of the most useful filters is already a huge advantage.</p>
<p>This chapter begins by introducing several extremely common <strong>linear</strong> and <strong>nonlinear filters</strong> for image processing.
It ends by considering in detail some techniques based on one particularly important linear filter.</p>
</section>
<section id="linear-filters">
<span id="sec-filters-linear"></span><h2>Linear filters<a class="headerlink" href="#linear-filters" title="Permalink to this headline">#</a></h2>
<p>Linear filters replace each pixel with a <strong>linear combination</strong> (‘sum of products’) of other pixels.
Therefore the only mathematical background they require is the ability to add and multiply.</p>
<p>A linear filter is defined using a <strong>filter kernel</strong>, which is like a tiny image in which the pixels are called <strong>filter coefficients</strong>.
To filter an image, we center the kernel over each pixel of the input image.
We then multiply each filter coefficient by the input image pixel that it overlaps, summing the result to give our filtered pixel value.
Some examples should make this clearer.</p>
<section id="mean-filters">
<h3>Mean filters<a class="headerlink" href="#mean-filters" title="Permalink to this headline">#</a></h3>
<p>Arguably the simplest linear filter is the <strong>mean filter</strong>.
Each pixel value is simply replaced by the average (mean) of itself and its neighbors within a defined area.</p>
<p>A simple <strong>3×3 mean filter</strong> averages each pixel with its 8 immediate neighbors (above, below, left, right and diagonals).
The filter kernel contains 9 values, arranged as a 3×3 square.
Each coefficient is 1/9, meaning that together all coefficients sum to 1.</p>
<p>The process of filtering with a 3×3 mean filter kernel is demonstrated below:</p>
<video autoplay loop playsinline controls muted>
  <source src="../../../_static/videos/filter_3x3.mp4" type="video/mp4">
</video>
<p>One of the main uses of a 3×3 mean filter is to reduce some common types of image noise, including Gaussian noise and Poisson noise.</p>
<p>We’ll discuss the subject of noise in much more detail in a later chapter, <a class="reference internal" href="../../3-fluorescence/3-formation_noise/formation_noise.html#chap-formation-noise"><span class="std std-ref">Noise</span></a>, and demonstrate <em>why</em> a mean filter works to reduce it.
At this point, all we need to know about noise is that it acts like a random (positive or negative) error added to each pixel value, which obscures detail, messes with the histogram, and makes the image look grainy.</p>
<p><a class="reference internal" href="#fig-filt-reduce-noise"><span class="std std-numref">Fig. 80</span></a> provides an illustration of how effectively the 3×3 filter can reduce Gaussian noise in an image.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>from scipy import ndimage
import matplotlib.pyplot as plt

im = load_image(&#39;happy_cell.tif&#39;).astype(np.float32)
im = im[::2, ::2]
rng = np.random.default_rng(100)
im = im + rng.normal(size=im.shape) * 10

# Identify central row &amp; define how line should be displayed
row = im.shape[0] // 2
line_args = ([0, im.shape[1]-1], [row, row], &#39;w--&#39;)

# Create a 3x3 mean filter kernel
kernel = np.ones((3, 3))
kernel /= kernel.sum()

# Ensure aligned
# fig = create_figure(figsize=(8, 8))
fig, ax = plt.subplots(2, 3, sharex=&#39;col&#39;, sharey=&#39;row&#39;, figsize=(8, 5), dpi=200)

# Show images &amp; plots
show_image(im, title=&quot;(A) Original image&quot;, pos=231)
plt.plot(*line_args)

im_mean = ndimage.convolve(im, kernel)
show_image(im_mean, title=&quot;(B) Mean filtered&quot;, pos=232)
plt.plot(*line_args)

im_diff = im - im_mean
s = im_diff.std() * 3
show_image(im_diff, title=&quot;(C) Subtraction (A) - (B)&quot;, vmin=-s, vmax=s, pos=233)
plt.plot(*line_args)

show_plot(im[row, :], ylabel=&#39;Value&#39;, xlabel=&#39;x&#39;, pos=234)
show_plot(im_mean[row, :], xlabel=&#39;x&#39;, pos=235)
show_plot(im_diff[row, :], xlabel=&#39;x&#39;, pos=236)

plt.tight_layout()
glue_fig(&#39;fig_filt_reduce_noise&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-filt-reduce-noise">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_3_0.png" src="../../../_images/filters_3_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 80 </span><span class="caption-text">Filters can be used to reduce noise.
Applying a  3×3 mean filter makes the image smoother, as is particularly evident in the fluorescence plot made through the image center.
Computing the difference between images shows what the filter removed, which was mostly random noise (with a little bit of image detail as well).</span><a class="headerlink" href="#fig-filt-reduce-noise" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Our simple 3×3 mean filter could be easily modified in at least two ways:</p>
<ol class="simple">
<li><p>Its size could be increased. For example, instead of using just the pixels immediately adjacent to the one we are interested in, a 5×5 mean filter replaces each pixel by the average of a square containing 25 pixels, still centered on the main pixel of interest.</p></li>
<li><p>The average of the pixels in some other shape of region could be computed, not just an <em>n×n</em> square.</p></li>
</ol>
<p>Both of these adjustments can be achieved by changing the size of the filter kernel and its coefficients.</p>
<p>One common change is to make a ‘circular’ mean filter.
We can do this by defining the kernel in such a way that coefficients we want to ignore are set to 0, and the non-zero pixels approximate a circle.
The size of the filter is then defined in terms of a radius value (<a class="reference internal" href="#fig-filter-shapes"><span class="std std-numref">Fig. 81</span></a>).</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(8,4))

def make_disk(radius: float, width=5) -&gt; np.ndarray:
    &quot;&quot;&quot;
    Use a distance transform to create a circular disk filter
    &quot;&quot;&quot;
    from scipy.ndimage import distance_transform_edt
    k = np.zeros((width, width), dtype=bool)
    k[width//2, width//2] = 1
    # Different implementations treat the radius value differently...
    # here, we try to match ImageJ&#39;s filters for the figure
    return distance_transform_edt(~k) &lt;= radius + 0.5

kernels = [
    (&#39;3x3 square&#39;, np.pad(np.ones((3,3)), 1), (0.2, 0.2, 0.7)),
    (&#39;Circular, radius=1.5&#39;, make_disk(1.5), (0.2, 0.7, 0.2)),
    (&#39;Circular, radius=2.5&#39;, make_disk(2), (0.7, 0.2, 0.2)),
    (&#39;5x5 square&#39;, np.ones((5,5)), (0.6, 0.2, 0.6)),
]
colors = [(0.8, 0.2, 0.2)]
ii = 0
from matplotlib.colors import ListedColormap

# Show the kernels + grid (more code than you might expect...)
for name, kernel, c in kernels:
    ii += 1
    if ii == 1:
        show_image(kernel, vmin=0, vmax=1, cmap=ListedColormap([c+(0,), c+(0.4,)]), alpha = 1, title=name, pos=(1,len(kernels),ii))
    else:
        show_image(kernel, vmin=0, vmax=1, cmap=ListedColormap([c+(0.1,), c+(0.4,)]), alpha = 1, title=name, pos=(1,len(kernels),ii))
    s = int(kernel.sum())
    plt.xticks(ticks=np.arange(5)-0.5, labels=[])
    plt.yticks(ticks=np.arange(5)-0.5, labels=[])
    plt.xlim(-0.6, 4.6)
    plt.ylim(-0.6, 4.6)
    fd_main = {&#39;size&#39;: 10}
    fd_zero = {&#39;size&#39;: 8}
    for (i, j), z in np.ndenumerate(kernel):
        if z == 0:
            t = &#39;0&#39;
            fd = fd_zero
        else:
            t = r&#39;$\frac{1}{&#39;+str(s)+&#39;}$&#39;
            fd = fd_main
        plt.text(j, i, t, ha=&#39;center&#39;, va=&#39;center&#39;, fontdict=fd)
        plt.hlines(np.arange(6)-0.5, -0.5, 4.5, color=c+(0.25,), linewidth=0.25)
        plt.vlines(np.arange(6)-0.5, -0.5, 4.5, color=c+(0.25,), linewidth=0.25)
plt.show()

glue_fig(&#39;fig_filter_shapes&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-filter-shapes">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_5_1.png" src="../../../_images/filters_5_1.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 81 </span><span class="caption-text">The kernels used with several mean filters.
Note that there’s no clearly ‘right’ way to approximate a circle within a pixel grid, and as a result different software can create circular filters that are slightly different.
Here, (B) and (C) match the ‘circular’ filters used by ImageJ’s <span class="menuselection">Process ‣ Filters ‣ Mean…</span> command.</span><a class="headerlink" href="#fig-filter-shapes" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="info admonition">
<p class="admonition-title">Different names for (almost) the same thing</p>
<p>The world of filtering is full of concepts with multiple names, all meaning pretty much the same thing. For example:</p>
<ul class="simple">
<li><p><strong>linear filtering</strong> may be called <strong>convolution</strong> (very common) or <strong>correlation</strong><a class="footnote-reference brackets" href="#fn-conv" id="id1">1</a> (less common)</p></li>
<li><p>a <strong>filter kernel</strong> might be called a <strong>filter mask</strong></p></li>
<li><p><strong>mean filters</strong> are sometimes referred to as <strong>arithmetic mean filters</strong>, <strong>averaging filters</strong> or <strong>boxcar filters</strong></p></li>
</ul>
<p>Take your pick.
It’s worth knowing the equivalence to avoid being confused by the literature.
In particular, ‘convolve’ is used often enough as a synonym for ‘filter’ (with a linear filter) that it’s important to remember.</p>
</div>
<p>Increasing the size of a mean filter increases its impact.
This is not only in terms of reducing noise, but also in terms of reducing detail, i.e. making the image more blurry (<a class="reference internal" href="#fig-mean-filter-sizes"><span class="std std-numref">Fig. 82</span></a>).
If noise reduction is the primary goal, it’s therefore best to avoid unnecessary blurring by using the smallest filter that gives acceptable results.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Create a circular mean filter
def create_mean_kernel(radius: int):
    r = radius
    x = np.arange(-r, r+1)
    y = np.arange(-r, r+1)
    y, x = np.meshgrid(x, x)
    mask = x*x + y*y &lt;= r*r
    kernel = mask.astype(np.float64)
    return kernel / kernel.sum()


from scipy import ndimage
import matplotlib.pyplot as plt

im = load_image(&#39;happy_cell.tif&#39;).astype(np.float32)
im = im[::2, ::2]
rng = np.random.default_rng(100)
im = im + rng.normal(size=im.shape) * 10

kernels = {
    &#39;Original image&#39;: None,
    &#39;Filtered, radius=1&#39;: create_mean_kernel(1),
    &#39;Filtered, radius=5&#39;: create_mean_kernel(5),
    &#39;Filtered, radius=10&#39;: create_mean_kernel(10)
}

# Identify central row &amp; define how line should be displayed
row = im.shape[0] // 2
line_args = ([0, im.shape[1]-1], [row, row], &#39;w--&#39;)

# Ensure aligned
# fig = create_figure(figsize=(8, 8))
fig, ax = plt.subplots(2, len(kernels), sharex=&#39;col&#39;, figsize=(8, 4), dpi=200)

count = 0
n = len(kernels)
for title, kernel in kernels.items():
    count += 1
    if kernel is None:
        im_filtered = im
    else:
        im_filtered = ndimage.convolve(im, kernel)

    # Show images &amp; plots
    show_image(im_filtered, title=title, pos=(2, n, count))
    plt.plot(*line_args)

    show_plot(im_filtered[row, :], xlabel=&#39;x&#39;, pos=(2, n, n+count))
    plt.ylim([-20, 80])
    if count &gt; 1:
        plt.yticks([])
    else:
        plt.ylabel(&#39;Value&#39;)

plt.tight_layout()
glue_fig(&#39;fig_mean_filter_sizes&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-mean-filter-sizes">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_7_0.png" src="../../../_images/filters_7_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 82 </span><span class="caption-text">Smoothing an image using circular mean filters with different radii.</span><a class="headerlink" href="#fig-mean-filter-sizes" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="sd-tab-set docutils">
<input checked="checked" id="eb548b70-921f-4556-b4fa-b8905b8de37c" name="52cfbca7-56e6-47fc-b676-13467c0b723d" type="radio">
</input><label class="sd-tab-label" for="eb548b70-921f-4556-b4fa-b8905b8de37c">
Question</label><div class="sd-tab-content docutils">
<p>In ImageJ, creating a mean filter with <em>Radius = 6</em> results in a circular filter that replaces each pixel with the mean of 121 pixels.
Using a square
11×11 filter would also replace each pixel with the mean of 121 pixels.</p>
<p>Can you think of any advantages in using the circular filter rather than the square filter?</p>
</div>
<input id="1eb1b0fb-a8ba-4b8d-b90f-e490e63162e7" name="52cfbca7-56e6-47fc-b676-13467c0b723d" type="radio">
</input><label class="sd-tab-label" for="1eb1b0fb-a8ba-4b8d-b90f-e490e63162e7">
Answer</label><div class="sd-tab-content docutils">
<p>Circles are more ‘compact’.
Every point on the perimeter of a circle is the same distance from the center.
Therefore using a circular filter involves calculating the mean of all pixels a distance of <span class="math notranslate nohighlight">\(\leq\)</span> <em>Radius</em> pixels away from the center.</p>
<p>For a square filter, pixels that are further away in diagonal directions than horizontal or vertical directions are allowed to influence the results.
If a pixel is further away, it’s more likely to have a very different value because it is part of some other structure.
Averaging across structures can blur them into one another, so is best avoided.</p>
</div>
</div>
</section>
<section id="gradient-filters">
<span id="sec-filters-gradient"></span><h3>Gradient filters<a class="headerlink" href="#gradient-filters" title="Permalink to this headline">#</a></h3>
<p>Linear filters can do much more than simply compute local averages.
We only need to define a new filter kernel with different coefficients.</p>
<p>Often, we want to detect structures in an image that are distinguishable from the background because of their edges.
Being able to detect the edges could therefore be useful.
Because an edge is usually characterized by a relatively sharp transition in pixel values – i.e. by a steep increase or decrease in the profile across the image – <strong>gradient filters</strong> can be used to help.</p>
<p>A very simple gradient filter has the coefficients <em>-1, 0, 1</em>.
Applied to an image, this replaces every pixel with the difference between the pixel to the right and the pixel to the left.
The output is positive whenever the pixel values are increasing horizontally, negative when the pixel values are decreasing, and zero if the values are constant – <em>no matter what the original constant value was</em>, so that flat areas are zero in the gradient image irrespective of their original brightness.
We can also rotate the filter by 90 and get a vertical gradient image (<a class="reference internal" href="#fig-processing-filters-gradient"><span class="std std-numref">Fig. 83</span></a>).</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(8, 4))

im = load_image(&#39;happy_cell.tif&#39;)

kernel_horizontal = np.asarray([-1, 0, 1]).reshape((1, 3))
kernel_vertical = np.asarray([-1, 0, 1]).reshape((3, 1))

im_horizontal = ndimage.convolve(im, kernel_horizontal)
show_image(im_horizontal, title=&quot;(A) Horizontal gradient&quot;, pos=131)

im_vertical = ndimage.convolve(im, kernel_vertical)
show_image(im_vertical, title=&quot;(B) Vertical gradient&quot;, pos=132)

im_grad_mag = np.sqrt(im_horizontal*im_horizontal + im_vertical*im_vertical)
show_image(im_grad_mag, title=&quot;(C) Gradient magnitude&quot;, pos=133)

glue_fig(&#39;fig_processing_filters_gradient&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-processing-filters-gradient">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_10_0.png" src="../../../_images/filters_10_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 83 </span><span class="caption-text">Using gradient filters and the gradient magnitude for edge enhancement.</span><a class="headerlink" href="#fig-processing-filters-gradient" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Having two gradient images with positive and negative values can be somewhat hard to work with.
We can combine filtering with <a class="reference internal" href="../2-point_operations/point_operations.html#chap-point-operations"><span class="std std-ref">point operations</span></a> to generate a single image representing the <strong>gradient magnitude</strong> <a class="footnote-reference brackets" href="#fn-3" id="id2">2</a>.
The gradient magnitude has high values around edges (regardless of their orientation), and low values everywhere else.</p>
<p>The process of calculating the gradient magnitude is:</p>
<ul class="simple">
<li><p>Apply linear filters to produce the horizontal and vertical gradient images</p></li>
<li><p><em>Square</em> all the pixel values in both gradient images</p></li>
<li><p>Add the squared images together</p></li>
<li><p>Take the square root of the result</p></li>
</ul>
<div class="sd-tab-set docutils">
<input checked="checked" id="a05223c3-99e0-4d9b-84aa-ed574a5f5878" name="9225819b-515c-41d8-b8d2-04843d7cd57a" type="radio">
</input><label class="sd-tab-label" for="a05223c3-99e0-4d9b-84aa-ed574a5f5878">
Question</label><div class="sd-tab-content docutils">
<p>Suppose the mean pixel value of an image is 100.
What will the mean value be after applying a horizontal gradient filter?</p>
</div>
<input id="4f456033-ee76-4722-9889-e9de95983613" name="9225819b-515c-41d8-b8d2-04843d7cd57a" type="radio">
</input><label class="sd-tab-label" for="4f456033-ee76-4722-9889-e9de95983613">
Solution</label><div class="sd-tab-content docutils">
<p>After applying a gradient filter, the image mean will be 0: every pixel is added once and subtracted once when calculating the result.</p>
<p>(Note that the mean value of a <em>gradient magnitude</em> image will be ≥ 0, because all pixels have either positive values or are equal to zero.)</p>
</div>
</div>
<aside class="margin sidebar">
<p class="sidebar-title"></p>
<img alt="../../../_images/filter_corner.png" src="../../../_images/filter_corner.png" />
</aside>
</section>
<section id="filtering-at-image-boundaries">
<h3>Filtering at image boundaries<a class="headerlink" href="#filtering-at-image-boundaries" title="Permalink to this headline">#</a></h3>
<p>If a filter consists of more than one coefficient, the neighborhood will extend beyond the image boundaries when filtering some pixels nearby.
We need to handle this somehow.
There are several common approaches.</p>
<p>The boundary pixels could simply be ignored and left with their original values, but for large neighborhoods this would result in much of the image being unfiltered.
Alternative options include treating every pixel beyond the boundary as zero, replicating the closest valid pixel, treating the image as if it is part of a periodic tiling, or mirroring the internal values (<a class="reference internal" href="#fig-filter-boundaries"><span class="std std-numref">Fig. 84</span></a>).</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&quot;&quot;&quot;
Illustrate different boundary padding methods that may be used with convolution.
&quot;&quot;&quot;

fig = create_figure(figsize=(8, 4))

im = load_image(&#39;/images/boundary_demo.png&#39;)
pad_size = 100

im_padded = np.pad(im, pad_size, mode=&#39;constant&#39;, constant_values=im.max())
show_image(im_padded, title=&quot;(A) Original image&quot;, pos=231)

im_zeros = np.pad(im, pad_size, mode=&#39;constant&#39;)
show_image(im_zeros, title=&quot;(B) Zeros&quot;, pos=232)

im_replicate = np.pad(im, pad_size, mode=&#39;edge&#39;)
show_image(im_replicate, title=&quot;(C) Edge replication&quot;, pos=233)

im_circular = np.pad(im, pad_size, mode=&#39;wrap&#39;)
show_image(im_circular, title=&quot;(D) Wrapped/circular&quot;, pos=234)

im_symmetric = np.pad(im, pad_size, mode=&#39;symmetric&#39;)
show_image(im_symmetric, title=&quot;(E) Symmetric&quot;, pos=235)

im_extra = np.pad(im, pad_size, mode=&#39;linear_ramp&#39;)
show_image(im_extra, title=&quot;(E) Linear ramp&quot;, pos=236)

glue_fig(&#39;fig_filter_boundaries&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-filter-boundaries">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_12_0.png" src="../../../_images/filters_12_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 84 </span><span class="caption-text">Methods for determining suitable values for pixels beyond image boundaries when filtering.</span><a class="headerlink" href="#fig-filter-boundaries" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Different software can handle boundaries in different ways.
Often, if you are using an image processing library to code your own filtering operation you will be able to specify the boundary operation.</p>
</section>
</section>
<section id="nonlinear-filters">
<h2>Nonlinear filters<a class="headerlink" href="#nonlinear-filters" title="Permalink to this headline">#</a></h2>
<p>Linear filters involve taking neighborhoods of pixels, scaling them by the filter coefficients, and adding the results to get new pixel values.
<strong>Nonlinear filters</strong> also make use of neighborhoods of pixels, but can use any other type of calculation to obtain the output.
Here we’ll consider one especially important family of nonlinear filters.</p>
<section id="rank-filters">
<span id="sec-filters-rank"></span><h3>Rank filters<a class="headerlink" href="#rank-filters" title="Permalink to this headline">#</a></h3>
<p><strong>Rank filters</strong> effectively sort the values of all the neighboring pixels in ascending order, and then choose the output based upon this ordered list.</p>
<p>Perhaps the most common example is the <strong>median filter</strong>, in which the pixel value at the center of the list is used for the filtered output.</p>
<figure class="align-center" id="fig-rank-results">
<img alt="../../../_images/rank_results.png" src="../../../_images/rank_results.png" />
<figcaption>
<p><span class="caption-number">Fig. 85 </span><span class="caption-text">Results of different 3×3 rank filters when processing a single neighborhood in an image.
The output of a
3×3 mean filter in this case would also be 15.</span><a class="headerlink" href="#fig-rank-results" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The result of applying a median filter is often similar to that of applying a mean filter, but has the major advantage of removing isolated extreme values completely, <em>without allowing them to have an impact upon surrounding pixels</em>.
This is in contrast to a mean filter, which cannot ignore extreme pixels but rather will smooth them out into occupying larger regions (<a class="reference internal" href="#fig-processing-filters-speckled"><span class="std std-numref">Fig. 86</span></a>).</p>
<p>However, a disadvantage of a median filter is that it can seem to introduce patterns or textures that were not present in the original image, at least whenever the size of the filter increases (see <a class="reference internal" href="#fig-processing-filters"><span class="std std-numref">Fig. 90</span></a>D below).
Another disadvantage is that large median filters tend to be slow.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&quot;&quot;&quot;
Illustrate how median filters remove salt-and-pepper noise more cleanly than mean filters.
(Note: most noise isn&#39;t like this, and median filters aren&#39;t always preferable)
&quot;&quot;&quot;

fig = create_figure(figsize=(8, 4))

from mpl_toolkits.axes_grid1.inset_locator import zoomed_inset_axes

def add_inset(ax, im, loc=[50, 50, 160, 160], edge_color=&#39;black&#39;, **kwargs):
    axins = zoomed_inset_axes(ax, zoom=4, loc=&#39;upper left&#39;)
    x = 340
    y = 210
    s = 40
    axins.imshow(im, cmap=&#39;gray&#39;, interpolation=&#39;nearest&#39;, **kwargs)
    axins.set_xlim(x, x+s)
    axins.set_ylim(y+s, y)
    axins.set_xticks([])
    axins.set_yticks([])
    ax.indicate_inset_zoom(axins, edgecolor=edge_color)


im = load_image(&#39;fixed_cells.png&#39;)

# Add salt-and-pepper noise by creating uniformly distributed noise,
# then thresholding to choose which pixels should become black and white
threshold = 0.05
rng = np.random.default_rng(100)
im_random = rng.random(size=im.shape)
im[im_random &lt; threshold] = 0
im[im_random &gt; 1-threshold] = 255
show_image(im, title=&quot;(A) Salt &amp; pepper noise&quot;, pos=131, origin=&quot;upper&quot;)
add_inset(plt.gca(), im)

# 3x3 mean filter
kernel = np.ones((3, 3))
kernel = kernel / kernel.sum()
im_mean = ndimage.convolve(im, kernel)
show_image(im_mean, title=&quot;(B) Mean filter&quot;, pos=132)
add_inset(plt.gca(), im_mean)

# 3x3 median filter
im_median = ndimage.median_filter(im, size=3)
show_image(im_median, title=&quot;(C) Median filter&quot;, pos=133)
add_inset(plt.gca(), im_median)

glue_fig(&#39;fig_processing_filters_speckled&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-processing-filters-speckled">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_14_0.png" src="../../../_images/filters_14_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 86 </span><span class="caption-text">Applying 3×3 mean and median filters to an image containing isolated extreme values (known as <em>salt and pepper noise</em>).
A mean filter reduces the intensity of the extreme values but spreads out their influence.
A small median filter is capable of removing the outliers completely, with a minimal effect upon the rest of the image.</span><a class="headerlink" href="#fig-processing-filters-speckled" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Other rank filters include the <strong>minimum</strong> and <strong>maximum filters</strong>, which replace each pixel value with the minimum or maximum value in the surrounding neighborhood respectively (<a class="reference internal" href="#fig-processing-filters-rank"><span class="std std-numref">Fig. 87</span></a>).
They will become more important when we discuss <a class="reference internal" href="../5-morph/morph.html#chap-morph"><span class="std std-ref">morphological operations</span></a>.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&quot;&quot;&quot;
Compare median, maximum and minimum filters.
&quot;&quot;&quot;

fig = create_figure(figsize=(8, 4))

im = load_image(&#39;fixed_cells.png&#39;)

filt_size = 3
im_median = ndimage.median_filter(im, size=filt_size)
im_max = ndimage.maximum_filter(im, size=filt_size)
im_min = ndimage.minimum_filter(im, size=filt_size)

show_image(im_median, title=&quot;(A) Median filter&quot;, pos=131)
add_inset(plt.gca(), im_median)
show_image(im_max, title=&quot;(B) Maximum filter&quot;, pos=132)
add_inset(plt.gca(), im_max)
show_image(im_min, title=&quot;(C) Minimum filter&quot;, pos=133)
add_inset(plt.gca(), im_min)
glue_fig(&#39;fig_processing_filters_rank&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-processing-filters-rank">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_16_0.png" src="../../../_images/filters_16_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 87 </span><span class="caption-text">The result of applying 3×3 rank filters. The original noise-free image is shown below in <a class="reference internal" href="#fig-processing-filters"><span class="std std-numref">Fig. 90</span></a>A.</span><a class="headerlink" href="#fig-processing-filters-rank" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&quot;&quot;&quot;
Compute maximum minus minimum to show it enhances edges.
&quot;&quot;&quot;

fig = create_figure(figsize=(2, 2))

im = load_image(&#39;fixed_cells.png&#39;)

filt_size = 3
im_max = ndimage.maximum_filter(im, size=filt_size)
im_min = ndimage.minimum_filter(im, size=filt_size)

show_image(im_max - im_min)
glue_fig(&#39;fig_filters_max_minus_min&#39;, fig)
</pre></div>
</div>
</div>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="7a409ac4-6106-4db7-9f8c-a8cc1106bf4b" name="bee34f8a-ac68-4aba-9cd2-4c8511794510" type="radio">
</input><label class="sd-tab-label" for="7a409ac4-6106-4db7-9f8c-a8cc1106bf4b">
Question</label><div class="sd-tab-content docutils">
<p>What would happen if you subtract a minimum filtered image (e.g.
<a class="reference internal" href="#fig-processing-filters-rank"><span class="std std-numref">Fig. 87</span></a>C) from a maximum filtered image (Figure <a class="reference internal" href="#fig-processing-filters-rank"><span class="std std-numref">Fig. 87</span></a>B)?</p>
</div>
<input id="47eb6e92-add0-4480-8746-2358824f287d" name="bee34f8a-ac68-4aba-9cd2-4c8511794510" type="radio">
</input><label class="sd-tab-label" for="47eb6e92-add0-4480-8746-2358824f287d">
Answer</label><div class="sd-tab-content docutils">
<p>Subtracting a minimum from a maximum filtered image would be another way to accent the edges:</p>
<figure class="align-center">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_18_0.png" src="../../../_images/filters_18_0.png" />
</div>
</figure>
</div>
</div>
</section>
</section>
<section id="gaussian-filters">
<span id="sec-filters-gaussian"></span><h2>Gaussian filters<a class="headerlink" href="#gaussian-filters" title="Permalink to this headline">#</a></h2>
<section id="filters-from-gaussian-functions">
<h3>Filters from Gaussian functions<a class="headerlink" href="#filters-from-gaussian-functions" title="Permalink to this headline">#</a></h3>
<p>We conclude this chapter with one fantastically important linear filter, and some variants based upon it.</p>
<p>A <strong>Gaussian filter</strong> is a linear filter that also smooths an image and reduces noise.
However, unlike a mean filter – for which even the furthest away pixels in the neighborhood influence the result by the same amount as the closest pixels – the smoothing of a Gaussian filter is weighted so that the influence of a pixel decreases with its distance from the filter center.
This tends to give a better result in many cases (<a class="reference internal" href="#fig-filt-smoothing"><span class="std std-numref">Fig. 88</span></a>).</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&quot;&quot;&quot;
Illustrate difference in mean &amp; Gaussian filter.
Note that filter sizes here are a matter of taste -- there&#39;s nothing special about the values.
&quot;&quot;&quot;

fig = create_figure(figsize=(8, 4))

# Create a simple image with some points
n = 10
im = np.zeros((n, n))
im[0, 6] = 3
im[5, 0] = 2
im[9, 9] = 1
im = np.pad(im, 10)

show_image(im, pos=131)

# Create Mean filter
kernel = create_mean_kernel(6)
im_mean = ndimage.convolve(im, kernel)
show_image(im_mean, pos=132)

# Create a Gaussian filter
im_gauss = ndimage.gaussian_filter(im, 4)
show_image(im_gauss, pos=133)

glue_fig(&#39;fig_filt_smoothing&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-filt-smoothing">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_20_0.png" src="../../../_images/filters_20_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 88 </span><span class="caption-text">Comparing a mean and Gaussian filter.
The mean filter can introduce patterns and maxima where previously there were none.
For example, the brightest region in (B) is one such maximum – <em>but the values of all pixels in the same region in (A) were zero!</em> By contrast, the Gaussian filter produces a smoother, more visually pleasing result, somewhat less prone to this effect (C).</span><a class="headerlink" href="#fig-filt-smoothing" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The coefficients of a Gaussian filter are determined from a Gaussian function (<a class="reference internal" href="#fig-gaussian-2d"><span class="std std-numref">Fig. 89</span></a>)</p>
<div class="math notranslate nohighlight">
\[
g(x, y) = Ae^{-(\frac{x^2 + y^2}{2\sigma^2})}
\]</div>
<p>The scaling factor <span class="math notranslate nohighlight">\(A\)</span> is used to make the entire volume under the surface equal to 1.
In terms of filtering, this means that the coefficients add to 1 and the image will not be unexpectedly scaled.
The size of the function is controlled by <span class="math notranslate nohighlight">\(\sigma\)</span>, rather than a filter radius.
<span class="math notranslate nohighlight">\(\sigma\)</span> is equivalent to the standard deviation of a normal (i.e. Gaussian) distribution.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>&quot;&quot;&quot;
Create a surface plot of a 2D Gaussian function.
&quot;&quot;&quot;

from matplotlib import cm
from matplotlib.colors import LightSource

n = 50
x = np.arange(-n, n+1, 1)
y = np.arange(-n, n+1, 1)
x, y = np.meshgrid(x, y)

sigma = 10
z = np.exp(-(x*x + y*y)/(2*sigma*sigma))

ls = LightSource()
z = z / z.max()
rgb = ls.shade(z, cmap=cm.get_cmap(&#39;plasma&#39;), blend_mode=&#39;soft&#39;)

# Create surface plots
surf_args = dict(
    facecolors = rgb,
    antialiased = False,
    linewidth = 0,
    shade = False,
    rstride = 1,
    cstride = 1
)
fig, ax = plt.subplots(1, 1, subplot_kw=dict(projection=&#39;3d&#39;, elev=30), dpi=200, figsize=(4, 3))
ax.plot_surface(x, y, z, **surf_args)
ax.axis(False)

glue_fig(&#39;fig_filters_math_gaussian_2d&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-gaussian-2d" style="width: 70%">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_22_0.png" src="../../../_images/filters_22_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 89 </span><span class="caption-text">Surface plot of a 2D Gaussian function.</span><a class="headerlink" href="#fig-gaussian-2d" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>A comparison of several filters is shown in <a class="reference internal" href="#fig-processing-filters"><span class="std std-numref">Fig. 90</span></a>.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(8, 12))

im = load_image(&#39;fixed_cells.png&#39;).astype(np.float32) / 255
rng = np.random.default_rng(100)
im_noisy = im + rng.normal(size=im.shape) / 8

show_args = dict(
    vmin = np.percentile(im_noisy, 1),
    vmax = np.percentile(im_noisy, 99)
)

show_image(im, title=&quot;(A) Original, noise-free image&quot;, pos=321)
add_inset(plt.gca(), im)

show_image(im_noisy, title=&quot;(B) Noisy image&quot;, **show_args, pos=322)
add_inset(plt.gca(), im_noisy, **show_args)

kernel = create_mean_kernel(3)
im_mean = ndimage.convolve(im_noisy, kernel)
show_image(im_mean, title=&quot;(C) Mean filtered, radius = 3&quot;, **show_args, pos=323)
add_inset(plt.gca(), im_mean, **show_args)

im_median = ndimage.median_filter(im_noisy, footprint=kernel &gt; 0)
show_image(im_median, title=&quot;(D) Median filtered, radius = 3&quot;, **show_args, pos=324)
add_inset(plt.gca(), im_median, **show_args)

im_gauss_1 = ndimage.gaussian_filter(im_noisy, 1)
show_image(im_gauss_1, title=&quot;(E) Gaussian filtered, $\sigma = 1$&quot;, **show_args, pos=325)
add_inset(plt.gca(), im_gauss_1, **show_args)

im_gauss_4 = ndimage.gaussian_filter(im_noisy, 3)
show_image(im_gauss_4, title=&quot;(F) Gaussian filtered, $\sigma = 3$&quot;, **show_args, pos=326)
add_inset(plt.gca(), im_gauss_4, **show_args)

glue_fig(&#39;fig_processing_filters&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-processing-filters">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_24_0.png" src="../../../_images/filters_24_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 90 </span><span class="caption-text">The effects of various filters upon a noisy image of a fixed cell.</span><a class="headerlink" href="#fig-processing-filters" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="filters-of-varying-sizes">
<span id="chap-filters-gaussian-size"></span><h3>Filters of varying sizes<a class="headerlink" href="#filters-of-varying-sizes" title="Permalink to this headline">#</a></h3>
<p>Gaussian filters have useful properties that make them generally preferable to mean filters, some of which will be mentioned in <a class="reference internal" href="../../3-fluorescence/2-formation_spatial/formation_spatial.html#chap-formation-spatial"><span class="std std-ref">Blur &amp; the PSF</span></a> (others require a trip into Fourier space, beyond the scope of this book).
Therefore if you’re not sure which filter to use for smoothing, Gaussian is likely to be a safer choice than mean – particularly if the filter is large.
Nevertheless, your decisions are not at an end since the precise size of the filter still needs to be chosen.</p>
<p>A small filter will mostly suppress noise, because noise masquerades as tiny random fluctuations at individual pixels.
As the filter size increases, Gaussian filtering starts to suppress larger structures occupying multiple pixels – reducing their intensities and increasing their sizes, until eventually they would be smoothed into surrounding regions (<a class="reference internal" href="#fig-gaussian-effects"><span class="std std-numref">Fig. 91</span></a>).
By varying the filter size, we can then decide the <strong>scale</strong> at which the processing and analysis should happen.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span># Read image, extract first channel &amp; crop a bit
x = 40
y = 168
w = 100
im = load_image(&#39;hela-cells.zip&#39;)[y:y+w, x:x+w, 0]

from scipy import ndimage
import matplotlib.pyplot as plt

sigmas = [0, 1, 2, 4]

# Identify central row &amp; define how line should be displayed
row = im.shape[0] // 2
line_args = ([0, im.shape[1]-1], [row, row], &#39;w--&#39;)

# Ensure aligned
# fig = create_figure(figsize=(8, 8))
fig, ax = plt.subplots(2, len(sigmas), sharex=&#39;col&#39;, figsize=(8, 4), dpi=200)

n = len(sigmas)
for count, sigma in enumerate(sigmas):
    if sigma:
        im_filtered = ndimage.gaussian_filter(im, sigma)
        title = f&#39;Gaussian filtered $\sigma={sigma}$&#39;
    else:
        im_filtered = im
        title = &#39;Original image&#39;

    # Show images &amp; plots
    show_image(im_filtered, title=title, pos=(2, n, count+1))
    plt.plot(*line_args)

    show_plot(im_filtered[row, :], xlabel=&#39;x&#39;, pos=(2, n, n+count+1))
    plt.ylim([0, 2200])
    plt.grid(True, axis=&#39;y&#39;, alpha=0.5)
    if count &gt; 0:
        plt.yticks(ticks=np.arange(500, 2001, 500), labels=[])
    else:
        plt.yticks(ticks=np.arange(500, 2001, 500))
        plt.ylabel(&#39;Value&#39;)

plt.tight_layout()
glue_fig(&#39;fig_gaussian_effects&#39;, fig)



# fig = create_figure(figsize=(8, 4))
# show_image(&#39;images/gaussian_effects_sigma_0.png&#39;, title=&quot;(A) Original image&quot;, pos=231)
# show_image(&#39;images/gaussian_effects_sigma_2.png&#39;, title=&quot;(B) Gaussian $\sigma = 2$&quot;, pos=232)
# show_image(&#39;images/gaussian_effects_sigma_5.png&#39;, title=&quot;(C) Gaussian $\sigma = 5$&quot;, pos=233)

# show_image(&#39;images/gaussian_effects_plot.png&#39;, title=&quot;(D) Profile plots of the intensity in the red channel of the image&quot;, pos=234)
# glue_fig(&#39;fig_gaussian_effects&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-gaussian-effects">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_26_0.png" src="../../../_images/filters_26_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 91 </span><span class="caption-text">The effect of Gaussian filtering on the size and intensity of structures.</span><a class="headerlink" href="#fig-gaussian-effects" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p><a class="reference internal" href="#fig-edge-sigma"><span class="std std-numref">Fig. 92</span></a> shows an example of when this is useful.
Here, gradient magnitude images are computed, similar to what was shown in <a class="reference internal" href="#fig-processing-filters-gradient"><span class="std std-numref">Fig. 83</span></a>, but because the original image is now noisy the initial result is not very useful – with even strong edges being buried amid noise (B).
Applying a small Gaussian filter prior to computing the gradient magnitude gives much better results (C).
If we only want the very strongest edges, then apply a larger filter would be better (D).</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(8, 4))

def grad_mag(im):
    &quot;&quot;&quot;
    Calculate a gradient magnitude image
    &quot;&quot;&quot;
    kernel_h = np.asarray([-1, 0, 1]).reshape((1, 3))
    kernel_v = np.asarray([-1, 0, 1]).reshape((3, 1))
    im_h = ndimage.convolve(im, kernel_h)
    im_v = ndimage.convolve(im, kernel_v)
    return np.sqrt(im_h*im_h + im_v*im_v)

# Get a noisy image
im = load_image(&#39;happy_cell.tif&#39;)
rng = np.random.default_rng(100)
im = im + rng.normal(size=im.shape) * 10

# Compute gradient magnitude with / without smoothing
im_sigma_0 = grad_mag(im)
im_sigma_2 = grad_mag(ndimage.gaussian_filter(im, 2))
im_sigma_5 = grad_mag(ndimage.gaussian_filter(im, 5))


show_image(im, title=&quot;(A) Original image&quot;, pos=141)
show_image(im_sigma_0, title=&quot;(B) No smoothing&quot;, clip_percentile=1, pos=142)
show_image(im_sigma_2, title=&quot;(C) Gaussian $\sigma=2$&quot;, pos=143)
show_image(im_sigma_5, title=&quot;(D) Gaussian $\sigma=5$&quot;, pos=144)
glue_fig(&#39;fig_edge_sigma&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-edge-sigma">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_28_0.png" src="../../../_images/filters_28_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 92 </span><span class="caption-text">Applying Gaussian filters before computing the gradient magnitude changes the scale at which edges are enhanced.</span><a class="headerlink" href="#fig-edge-sigma" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="difference-of-gaussians-filtering">
<span id="sec-filters-dog"></span><h3>Difference of Gaussians filtering<a class="headerlink" href="#difference-of-gaussians-filtering" title="Permalink to this headline">#</a></h3>
<p>So Gaussian filters can be chosen to suppress small structures.
But what if we also wish to suppress large structures – so that we can concentrate on detecting or measuring structures with sizes inside a particular range?</p>
<p>We already have the pieces necessary to construct one solution.</p>
<p>Suppose we apply one Gaussian filter to reduce small structures.
Then we apply a <em>second</em> Gaussian filter, bigger than the first, to a duplicate of the original image.
This will remove even more structures, while still preserving the largest features in the image.</p>
<p>The trick is that, if we subtract this second filtered image from the first, we are left with an image that contains the information that ‘falls between’ the two smoothing scales we used.</p>
<p>This process is called <strong>difference of Gaussians (DoG) filtering</strong>, and it is a technique that I use <em>all the time</em>.
It is especially useful for detecting small structures, or as an alternative to the gradient magnitude for enhancing edges (<a class="reference internal" href="#fig-dog-red-hela"><span class="std std-numref">Fig. 93</span></a>).</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(6, 6))

def dog_filter(im, sigma1, sigma2):
    &quot;&quot;&quot;
    Apply a difference of Gaussians filter
    &quot;&quot;&quot;
    im1 = ndimage.gaussian_filter(im.astype(np.float32), sigma1)
    im2 = ndimage.gaussian_filter(im.astype(np.float32), sigma2)
    return im1 - im2

# Read image, extract first channel &amp; crop a bit
x = 40
y = 40
im = load_image(&#39;hela-cells.zip&#39;)[y:y+446, x:x+446, 0]

show_image(im, title=&quot;(A) Original image&quot;, clip_percentile=0.5, pos=221)
show_image(dog_filter(im, 1, 2), title=&quot;(B) DoG, $\sigma = $1, 2&quot;, clip_percentile=0.5, pos=222)
show_image(dog_filter(im, 2, 4), title=&quot;(B) DoG, $\sigma = $2, 4&quot;, clip_percentile=0.5, pos=223)
show_image(dog_filter(im, 4, 8), title=&quot;(B) DoG, $\sigma = $4, 8&quot;, clip_percentile=0.5, pos=224)
glue_fig(&#39;fig_dog_red_hela&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-dog-red-hela">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_30_0.png" src="../../../_images/filters_30_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 93 </span><span class="caption-text">Difference of Gaussian filtering of the same image at various scales.</span><a class="headerlink" href="#fig-dog-red-hela" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>def gaussian_kernel(shape, sigma: float):
    &quot;&quot;&quot;
    Create an image with a single 1 in the middle,
    the apply a Gaussian filter to get the coefficients.
    &quot;&quot;&quot;
    filt = np.zeros(shape)
    filt[shape[0]//2, shape[1]//2] = 1.0
    return ndimage.gaussian_filter(filt, sigma)


from matplotlib import cm

n = 25
x = np.arange(-n, n+1, 1)
y = np.arange(-n, n+1, 1)
x, y = np.meshgrid(x, y)

# Define filter sigmas
sigma_small = 5
sigma_large = sigma_small * 1.6

# To view the filter coefficients, apply the filter to an image with a single 1
gauss_small = gaussian_kernel(x.shape, sigma_small)
gauss_large = gaussian_kernel(x.shape, sigma_large)
gauss_diff = gauss_small - gauss_large

# Create surface plots
surf_args = dict(
    cmap = cm.get_cmap(&#39;plasma&#39;),
    antialiased = False,
)
fig, ax = plt.subplots(1, 3, dpi=200, subplot_kw=dict(projection=&#39;3d&#39;, elev=25), figsize=(15, 5))
ax[0].plot_surface(x, y, gauss_small, **surf_args)
ax[1].plot_surface(x, y, gauss_large, **surf_args)
ax[2].plot_surface(x, y, gauss_diff, **surf_args)

ax[0].set_title(&#39;(A) Smaller Gaussian filter&#39;)
ax[1].set_title(&#39;(B) Larger Gaussian filter&#39;)
ax[2].set_title(&#39;(C) Difference of Gaussians filter&#39;)

# Set z-limits to match
max_val = gauss_small.max()
min_val = gauss_diff.min()
for a in ax:
    a.set_zlim(min_val, max_val)
    a.set_xticklabels([])
    a.set_yticklabels([])
    a.set_zticklabels([])

glue_fig(&#39;fig_dog_plots&#39;, fig)
</pre></div>
</div>
</div>
</div>
<div class="info admonition">
<p class="admonition-title">DoG filters</p>
<p>In fact, to get the result of DoG filtering it’s not necessary to filter the image twice and subtract the results.
We could equally well subtract the coefficients of the larger filter from the smaller first (after making sure both filters are the same size by adding zeros to the edges as required), then apply the resulting filter to the image only once (<a class="reference internal" href="#fig-dog-plots"><span class="std std-numref">Fig. 94</span></a>).</p>
<figure class="align-center" id="fig-dog-plots">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_32_0.png" src="../../../_images/filters_32_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 94 </span><span class="caption-text">Surface plots of two Gaussian filters with small and large <span class="math notranslate nohighlight">\(\sigma\)</span>, and the result of subtracting the latter from the former.
The sum of the coefficients for (A) and (B) is one in each case, while the coefficients of (C) add to zero.</span><a class="headerlink" href="#fig-dog-plots" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</section>
<section id="laplacian-of-gaussian-filtering">
<h3>Laplacian of Gaussian filtering<a class="headerlink" href="#laplacian-of-gaussian-filtering" title="Permalink to this headline">#</a></h3>
<p>One minor complication with DoG filtering is the need to select two different values of <span class="math notranslate nohighlight">\(\sigma\)</span>.
A similar operation, which requires only a single <span class="math notranslate nohighlight">\(\sigma\)</span> and a single filter, is <strong>Laplacian of Gaussian (LoG) filtering</strong>.</p>
<p>The appearance of a LoG filter is like an upside-down DoG filter (<a class="reference internal" href="#fig-log-plots"><span class="std std-numref">Fig. 95</span></a>), but if the resulting image is <a class="reference internal" href="../2-point_operations/point_operations.html#sec-points-inversion"><span class="std std-ref">inverted</span></a> then the results are comparable <a class="footnote-reference brackets" href="#fn-4" id="id3">3</a>.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(8, 4))

def log_kernel(shape, sigma: float):
    &quot;&quot;&quot;
    Create an image with a single 1 in the middle,
    the apply a Gaussian filter to get the coefficients.
    &quot;&quot;&quot;
    filt = np.zeros(shape)
    filt[shape[0]//2, shape[1]//2] = 1.0
    return ndimage.gaussian_laplace(filt, sigma)

n = 25
x = np.arange(-n, n+1, 1)
y = np.arange(-n, n+1, 1)
x, y = np.meshgrid(x, y)
sigma = 6

#
z_log = ((x*x + y*y - 2 * sigma*sigma)/(np.power(sigma, 4))) * np.exp(-(x*x + y*y)/(2 * sigma * sigma))

fig, ax = plt.subplots(1, 2, subplot_kw=dict(projection=&#39;3d&#39;, elev=25), figsize=(10, 5))
ax[0].plot_surface(x, y, z_log, **surf_args)
ax[1].plot_surface(x, y, -z_log, **surf_args)
for a in ax:
    a.set_xticklabels([])
    a.set_yticklabels([])
    a.set_zticklabels([])

ax[0].set_title(&#39;LoG filter&#39;)
ax[1].set_title(&#39;Inverted LoG filter&#39;)

glue_fig(&#39;fig_log_plots&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-log-plots">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_34_0.png" src="../../../_images/filters_34_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 95 </span><span class="caption-text">Surface plot of a LoG filter. This closely resembles <a class="reference internal" href="#fig-dog-plots"><span class="std std-numref">Fig. 94</span></a>, but inverted so that the negative values are found in the filter center.</span><a class="headerlink" href="#fig-log-plots" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(8, 4))

im = load_image(&#39;images/dog_on_log_orig.png&#39;).astype(np.float32)

show_image(im, title=&quot;(A) Dog on a log&quot;, pos=131)

sigma_dog = 2
im_dog = ndimage.gaussian_filter(im, sigma_dog) - ndimage.gaussian_filter(im, sigma_dog * 1.6)
show_image(im_dog, title=&quot;(B) DoG filtered dog&quot;, clip_percentile=0.25, pos=132)

sigma_log = 2
im_log = ndimage.gaussian_laplace(im, sigma_log)
show_image(im_log, title=&quot;(C) LoG filtered dog&quot;, clip_percentile=0.25, pos=133)

glue_fig(&#39;fig_dog_on_log&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-dog-on-log">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_36_0.png" src="../../../_images/filters_36_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 96 </span><span class="caption-text">Application of DoG and LoG filtering to an image.
Both methods enhance the appearance of spot-like structures, and (to a lesser extent) edges, and result in an image containing both positive and negative values with an overall mean of zero.
In the case of LoG filtering, inversion is involved: darker points become bright after filtering.</span><a class="headerlink" href="#fig-dog-on-log" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="unsharp-masking">
<h3>Unsharp masking<a class="headerlink" href="#unsharp-masking" title="Permalink to this headline">#</a></h3>
<p>Finally, a related technique widely-used to enhance the visibility of details in images – although certainly <em>not</em> advisable for quantitative analysis – is <strong>unsharp masking</strong>.</p>
<p>This uses a Gaussian filter first to blur the edges of an image, and then subtracts it from the original.
But rather than stop there, the subtracted image is multiplied by some weighting factor and <em>added back</em> to the original.
This gives an image that looks much the same as the original, but with edges sharpened by an amount dependent upon the chosen weight.</p>
<div class="cell tag_hide-cell tag_remove-output docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>fig = create_figure(figsize=(8, 4))

im = load_image(&#39;images/unsharp_masking_orig.png&#39;).astype(np.float32) / 255
if im.ndim &gt; 2:
    im = im[:, :, 0]

show_image(im, title=&quot;(A) Original image&quot;, pos=131)

sigma = 8
im_gauss = ndimage.gaussian_filter(im, sigma)
im_diff = im - im_gauss
show_image(im_diff, title=&quot;(B) Gaussian subtracted&quot;, clip_percentile=0.25, pos=132)

im_unsharp = im + im_diff * 2
im_unsharp = np.clip(im_unsharp, 0, 1)
show_image(im_unsharp, title=&quot;(C) Unsharp masked&quot;, pos=133)

glue_fig(&#39;fig_unsharp_masking&#39;, fig)
</pre></div>
</div>
</div>
</div>
<figure class="align-center" id="fig-unsharp-masking">
<div class="cell_output docutils container">
<img alt="../../../_images/filters_38_0.png" src="../../../_images/filters_38_0.png" />
</div>
<figcaption>
<p><span class="caption-number">Fig. 97 </span><span class="caption-text">The application of unsharp masking to a blurred image.
First a Gaussian-smoothed version of the image (<span class="math notranslate nohighlight">\(\sigma = 1\)</span>) is subtracted from the original, scaled (<span class="math notranslate nohighlight">\(weight = 0.7\)</span>) and added back to the original.</span><a class="headerlink" href="#fig-unsharp-masking" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Unsharp masking can improve the visual appearance of an image, but it’s important to remember that it modifies the image content in a way that might well be considered suspicious in scientific circles.
Therefore, if you apply unsharp masking to any image you intend to share with the world you should have a good justification and certainly admit what you have done.
The technique is included here not as a recommendation that you use it, but rather to show how Gaussian filters can be combined with point operations in creative ways.</p>
<p>If you want a more theoretically justified method to improve image sharpness in microscopy, it may be worth looking into <em>‘(maximum likelihood) deconvolution’</em> algorithms.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="fn-conv"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>I feel obliged to admit that there <em>is</em> a subtle difference between convolution and correlation: the kernel is rotated 180° for convolution.
This is something we almost never need to care about for two reasons:</p>
<ol class="simple">
<li><p>Convolution and correlation end up the same if the filter is symmetric – and most filters we care about are symmetric</p></li>
<li><p>The distinction is often ignored in practice anyway. For example, ImageJ has a <span class="menuselection">Process ‣ Filters ‣ Convolve…</span> command that (last time I checked) actually implements correlation.</p></li>
</ol>
</dd>
<dt class="label" id="fn-3"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>The equation then looks like Pythagoras’ theorem: <span class="math notranslate nohighlight">\(G_{mag} = \sqrt{G_x^2 + G_y^2}\)</span></p>
</dd>
<dt class="label" id="fn-4"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>A LoG filter is also often referred to as a <em>mexican-hat filter</em>, although clearly the filter (or the hat-wearer) should be inverted for the name to make more sense</p>
</dd>
</dl>
</section>
</section>
<div class="toctree-wrapper compound">
</div>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "bioimagebook/bioimagebook.github.io",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters/2-processing/4-filters"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../3-thresholding/imagej.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">ImageJ: Thresholding</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="imagej.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">ImageJ: Filters</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Pete Bankhead<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>